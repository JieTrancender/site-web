---
title: "Redis核心技术与实战 学习笔记 一"
date: 2021-01-21T19:52:11+08:00
tags: ["redis"]
categories: ["redis"]
toc: false
draft: true
---

Redis服务宕机后内存中的数据将全部丢失。从后端数据库恢复缓存数据会给数据库带来巨大压力且性能比不上Redis中读取；且如果Redis作为主数据库存储数据时则必须实现数据的持久化。Redis持久化主要有**AOF**(Append Only File)日志和**RDB**(Redis DataBase)快照。

<!--more-->

### Redis数据持久化

#### 1. AOF日志

不同于其它数据库的**写前日志**(Write Ahead Log,在实际写数据前先把数据记到日志文件中)，AOF是**写后日志**，数据写入内存后才记录日志，这样Redis收到的每一条命令执行后再以文本形式保存，不用额外的检查开销。

写后日志不能阻塞当前命令，但是可能阻塞后一个命令。AOF日志是在主线程中执行的，磁盘写入压力大时也可能导致阻塞的。为了折中解决这个问题Redis提供三个可选方案：

- Always：同步写回；每个写命令执行完立马同步落盘。
- Everysec：每秒写回；每个命令执行完后，只是先把日志写到AOF文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘。
- No：操作系统控制的写回；每个命令执行完后只是将日志写到AOF文件的内存缓冲区，由操作系统决定何时将缓冲区内容写入磁盘。

当AOF文件过大时也会带来性能问题：①文件系统本身对文件大小有限制，无法保存过大的文件；②向很大的文件追加命令记录时效率变低；③如果发生宕机，AOF记录的每个命令重新执行会非常缓慢，影响Redis的正常使用。

Redis使用**AOF重写机制**应对文件过大问题，即根据数据库的现状生成这些数据的插入命令，将Redis原来AOF文件中的同一key执行的多条命令变为一条命令。

AOF重写过程由后台子进程**bgrewriteaof**来完成的，不能导致主线程阻塞性能下降。

AOF重写时也有阻塞的风险：①fork子进程时会阻塞主线程，虽然fork采用操作系统提供的**写时复制机制**，不会一次性拷贝大量数据给子进程导致长时间阻塞；但fork子进程需要拷贝进程必须的数据结构，这个拷贝过程会消耗大量CPU资源，阻塞时间取决于整个示例的内存大小，实例越大，内存页表越大，阻塞时间越久。

*写时复制：写发生时才真正拷贝内存中的数据。内存分配是以页为单位进行分配的。*